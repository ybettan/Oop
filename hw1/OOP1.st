Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'getters' stamp: 'yb 4/12/2018 10:26'!coef	^coef.! !!Monom methodsFor: 'getters' stamp: 'yb 4/12/2018 11:33'!derivative	|res|	res := Monom new.		"return 0^0 for constant derivative"	(self exp = 0)		ifTrue: [			res coef: 0 ; exp: 0.		  	^res			].	res coef: (self coef) * (self exp).	res exp: (self exp) - 1.	^res.! !!Monom methodsFor: 'getters' stamp: 'yb 4/12/2018 09:33'!exp	^exp.! !!Monom methodsFor: 'initialize-release' stamp: 'yb 4/12/2018 09:35'!initialize	exp := 0.	coef := 0.! !!Monom methodsFor: 'setters' stamp: 'yb 4/12/2018 10:27'!coef: anInteger	((anInteger isKindOf: Integer) not)		ifTrue: [self error: 'invalid input'].			coef := anInteger.! !!Monom methodsFor: 'setters' stamp: 'yb 4/12/2018 09:33'!exp: anInteger	(((anInteger isKindOf: Integer) not) or: (anInteger < 0))		ifTrue: [self error: 'invalid input'].			exp := anInteger.! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'setters' stamp: 'dfdf 4/14/2018 12:31'!add: aPolyStream	| tmp |	"throw an exception in case of invalid inputs"	(aPolyStream isKindOf: PolyStream)		ifFalse: [self error: 'invalid input'].			"don't need to deepCopy aPolyStream since we can assume it won't change according to the exercise.	such a deepCopy would have increase the complexity"	tmp := self block.	block := [:x :filteredExps |				(tmp value: x value: filteredExps) + (aPolyStream block value: x value: filteredExps)].! !!PolyStream methodsFor: 'setters' stamp: 'dfdf 4/14/2018 16:02'!addCoef: coef withExp: exp	| tmp |	"throw an exception in case of invalid inputs"	(((coef isKindOf: Integer) and: (exp isKindOf: Integer)) and: (exp >= 0))		ifFalse: [self error: 'invalid input'].			"valid input"	tmp := self block.	"the new block will add the monom only if it is not in the filter set"	block := [:x :filteredExps |				(filteredExps includes: exp)					ifTrue: [(tmp value: x value: filteredExps)]					ifFalse: [(tmp value: x value: filteredExps) + (coef * (x raisedToInteger: exp))].				].! !!PolyStream methodsFor: 'setters' stamp: 'dfdf 4/14/2018 12:55'!filter: aSet	| tmp aSetCopy |	"make sure that future change on aSet won't affect the PolyStream.	this copy is of O(1) since the set size is constant as described in the exercise"	aSetCopy := aSet deepCopy.	tmp := self block.	block := [:x :filteredExps | tmp value: x value: aSetCopy].! !!PolyStream methodsFor: 'setters' stamp: 'dfdf 4/14/2018 16:01'!initialize	block := [:x :filteredSet | 0].! !!PolyStream methodsFor: 'setters' stamp: 'dfdf 4/14/2018 12:38'!multiplyBy: anInteger	| tmp |	"throw an exception in case of invalid inputs"	(anInteger isKindOf: Integer)		ifFalse: [self error: 'invalid input'].			"valid input"	tmp := self block.	block := [:x :filteredExps | anInteger * (tmp value: x value: filteredExps)].! !!PolyStream methodsFor: 'setters' stamp: 'dfdf 4/14/2018 12:35'!substitute: anInteger	| tmp |	"throw an exception in case of invalid inputs"	((anInteger isKindOf: Integer) and: (anInteger ~= 0))		ifFalse: [self error: 'invalid input'].			"compute the block with x->anInteger * x"	tmp := self block.	block := [:x :filteredExps | tmp value: (anInteger * x) value: filteredExps].! !!PolyStream methodsFor: 'getters' stamp: 'dfdf 4/14/2018 12:11'!block	^block.! !!PolyStream methodsFor: 'getters' stamp: 'dfdf 4/14/2018 13:04'!eval: anInteger		"throw an exception in case of invalid input"	"(anInteger isKindOf: Integer)		ifFalse: [self error: 'invalid input']."			"evaluate the Polynom"	^self block value: anInteger value: (Set new).! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'getters' stamp: 'yb 4/13/2018 10:20'!add: aPolynom	| res |	((aPolynom isKindOf: Polynom) not)		ifTrue: [self error: 'invalid input'].			res := Polynom new.	res := aPolynom deepCopy.	self asDictionary keysDo: [:key | |m|						m := Monom new.						m exp: key deepCopy ; coef: ((self asDictionary at: key) deepCopy).						res addMonom: m.						].	^res.	! !!Polynom methodsFor: 'getters' stamp: 'yb 4/12/2018 15:47'!asDictionary	^monoms deepCopy.! !!Polynom methodsFor: 'getters' stamp: 'yb 4/13/2018 09:10'!derivative	| res m |	res := Polynom new.	m := Monom new.	monoms keysDo: [:key | m exp: key ; coef: (monoms at: key).							m := m derivative.							(m coef ~= 0)								ifTrue: [res addMonom: m.].						].	^res.! !!Polynom methodsFor: 'getters' stamp: 'yb 4/13/2018 09:47'!eval: anInteger	| res |	(anInteger isKindOf: Integer)		ifFalse: [self error: 'invalid input'].			res := 0.	monoms keysDo: [:key | |coef|						coef := monoms at: key.						res := res + (coef * (anInteger raisedToInteger: key)).						].	^res.! !!Polynom methodsFor: 'setters' stamp: 'yb 4/12/2018 16:30'!addMonom: aMonom	| exp coef |	((aMonom isKindOf: Monom) not)		ifTrue: [self error: 'invalid input'].			"don't keep monoms with coef = 0"	(aMonom coef = 0) ifTrue: [^1].			"don't let change on aMonom affect the Polynom"	exp := aMonom exp deepCopy.	coef := aMonom coef deepCopy.		"if exp is already in monomy then add the coefs else insert a new element"	monoms at: exp 		ifPresent: [:currentCoef | monoms at: exp put: currentCoef + coef] 		ifAbsent: [monoms at: exp put: coef].	! !!Polynom methodsFor: 'setters' stamp: 'yb 4/12/2018 16:45'!multipleByMonom: aMonom	| exp coef newCollection |	((aMonom isKindOf: Monom) not)		ifTrue: [self error: 'invalid input'].		"don't let future change on aMonom affect the Polynom"	exp := aMonom exp deepCopy.	coef := aMonom coef deepCopy.		newCollection := Dictionary new.	monoms keysDo: [:key | |newExp newCoef|						newExp := key + exp.						newCoef := (monoms at: key) * coef.						(newCoef ~= 0) 							ifTrue: [newCollection at: newExp put: newCoef.].						].	monoms := newCollection.			! !!Polynom methodsFor: 'initialize-release' stamp: 'yb 4/12/2018 15:46'!initialize	monoms := Dictionary new.! !