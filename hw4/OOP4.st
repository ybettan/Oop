Object subclass: #OOPObject	instanceVariableNames: 'superclassInstances'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPObject methodsFor: 'setters' stamp: 'yb 6/12/2018 18:03'!initializeSupers	| superclassInstanceArrSize |		superclassInstanceArrSize := self class superclasses size.	superclassInstances := Array new: superclassInstanceArrSize.	(1 to: superclassInstanceArrSize) do: [ :i | superclassInstances at: i put: ( (self class superclasses at: i) parentClass new)].! !!OOPObject methodsFor: 'initialize-release' stamp: 'sdf 6/6/2018 19:55'!initialize	^self initializeSupers postInitialize.! !!OOPObject methodsFor: 'initialize-release' stamp: 'sdf 6/6/2018 19:55'!postInitialize	^self.! !!OOPObject methodsFor: 'getters' stamp: 'yb 6/12/2018 10:03'!definingInstance: aSymbol	| classifier parentRes |				classifier := self class classifyInheritedMethod: aSymbol.				( (classifier = 'undefined') or: (classifier = 'ambiguous') or: (classifier = 'inaccessible') )			ifTrue: [^nil].			"at this stage an instance must exist"		(1 to: superclassInstances size) do: [ :i |			( (superclassInstances at: i) class canUnderstand: aSymbol )				"check lower instances first"				ifTrue: [^(superclassInstances at: i)]				"then check higher instances"				ifFalse: [					parentRes := (superclassInstances at: i) definingInstance: aSymbol.					( parentRes ~~ nil )						ifTrue: [^parentRes].					].		].			Transcript show: 'ERROR - not possible we didnt find the instance' ; cr. "FIXME: remove when tested"! !!OOPObject methodsFor: 'error handling' stamp: 'yb 6/12/2018 16:15'!doesNotUnderstand: aMessage	| senderClass methodCalled methodSpecifier recieverInst havePermission methodExist |			"find the class that sent the message"		senderClass := thisContext client class.				"get the method selector"		methodCalled := aMessage selector.				"get the receiver instance"		recieverInst := self.				"get the method specifier"		methodSpecifier := recieverInst class classifyInheritedMethod: methodCalled.				"check if the method exist in the reciever class"		( (methodSpecifier = 'public') or: (methodSpecifier = 'protected') or: (methodSpecifier = 'private') )			ifTrue: [methodExist := true]			ifFalse: [methodExist := false].					"assuming the method exist in the reciever, check if the sender have parmission"		(methodSpecifier = 'public')			ifTrue: [havePermission := true].		( (methodSpecifier = 'protected') and: (senderClass isKindOf: recieverInst class) )			ifTrue: [havePermission := true].		( (methodSpecifier = 'private') and: (senderClass isMemberOf: recieverInst class) )			ifTrue: [havePermission := true].				( (methodExist) and: (havePermission) )			ifTrue: [				(recieverInst definingInstance: methodCalled) perform: methodCalled withArguments: aMessage arguments.			]			ifFalse: [senderClass throwSender: senderClass name asString fails: methodCalled inClass: recieverInst class name asString because: methodSpecifier].						! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OOPObject class	instanceVariableNames: 'superclasses'!!OOPObject class methodsFor: 'accessing class hierarchy' stamp: 'yb 6/12/2018 19:37'!multInheritsFrom: aClass	"stoping condition"	(superclasses size = 0)		ifTrue: [^false].		superclasses do: [ :sc | 		"check if inherits directly"		(sc parentClass = aClass)			ifTrue: [^true].		"for OOPObject derived check recursively"		(sc parentClass new isKindOf: OOPObject)			ifTrue: [				(sc parentClass multInheritsFrom: aClass)					ifTrue: [^true].			].	].		"we didn't found"	^false.! !!OOPObject class methodsFor: 'getters' stamp: 'sdf 6/9/2018 23:06'!classifyInheritedMethod: aSymbol		"The algorithm:	1. if the class don't have any superclasses --> 'undefined'	2. if more the 1 superclasses defines aSymbol --> 'ambigouos'	3. create a new array named superResults with the size of superclasses arr		- superResults[i] containes the the result of 'superclasses[i] classifyInheritedMethod: aSymbol' 	4. if all superResults[i] = 'undefined', then:		4.1 if 0 superclasses defines aSymbol --> return 'undefined'		4.2	else (must be that only 1 of the superclasses defines aSymbol) --> the inheritence classifyer	5. if only 1 of superResults[i] ~~ 'undefiend', then		5.1 if superResults[i] = 'ambigouos' or *another* superclass defines aSymbol --> 'ambigouos'		5.2 if only the *same* superclass defines aSymbol --> the most restricting between superResults[i] and the inheritence classifyer				5.3 if superResults[i] = 'private' --> 'inaccessible'		5.4 --> the most restricting between superResults[i] and the inheritence classifyer	6. if more than 1 of superResults[i] ~~ 'undefiend' --> 'ambigouos' "				| superResults declaringClasses undefinedCounter |				"1"		(self superclasses size = 0)			ifTrue: [^'undefined'].					"2"		declaringClasses := 0.		superclasses do:			[ :c | (c parentClass canUnderstand: aSymbol) ifTrue: [declaringClasses := declaringClasses + 1]].		(declaringClasses > 1)			ifTrue: [^'ambiguous'].					"3"		superResults := Array new: superclasses size.		(1 to: superResults size) do: 			[ :i | superResults at: i put: ( ( (superclasses at: i) parentClass) classifyInheritedMethod: aSymbol)].				"count how many superclasses returns 'undefined' result"		undefinedCounter := 0.		superResults do:			[ :superRes | (superRes = 'undefined') ifTrue: [undefinedCounter := undefinedCounter + 1]].				"4"		(undefinedCounter = superResults size)			ifTrue: [				(declaringClasses = 0)					ifTrue: [^'undefined']					ifFalse: [ "only 1 superclass defines aSymbol"						superclasses do:							[ :c | (c parentClass canUnderstand: aSymbol) ifTrue: [^(c inheritanceType)]].					].			].		"5"		(undefinedCounter = ( (superResults size) - 1) )			ifTrue: [				superResults do:					[ :superRes | (superRes = 'ambiguous') ifTrue: [^'ambiguous'].].				(1 to: superclasses size) do:					[ :i |						( (superclasses at: i) parentClass canUnderstand: aSymbol )							ifTrue: [								( (superResults at: i) = 'undefined')									ifTrue: [^'ambiguous'] 	"other class defines it"									ifFalse: [^(superclasses at: i) inheritanceType]. "overriding"							].					].				(1 to: superclasses size) do:					[ :i |						( (superResults at: i) ~~ 'undefined')							ifTrue: [								( (superResults at: i) = 'private')									ifTrue: [^'inaccessible'].								( ( (superclasses at: i) inheritanceType ) = 'private')									ifTrue: [^'private'].								( (superResults at: i) = 'protected')									ifTrue: [^'protected'].								( (superResults at: i) = 'public')									ifTrue: [^(superclasses at: i) inheritanceType].							].					].			].		"6"		^'ambiguous'.			! !!OOPObject class methodsFor: 'getters' stamp: 'sdf 6/6/2018 19:36'!superclasses	^superclasses.! !!OOPObject class methodsFor: 'error handling' stamp: 'yb 6/12/2018 10:58'!throwSender: senderName fails: methodName inClass: receiverName because: reason	| str |			str := senderName, ' cannot send ', methodName asString, ' to ', receiverName, ' because: ', reason.		AssertionFailure signal: str.! !!OOPObject class methodsFor: 'subclass creation' stamp: 'yb 6/12/2018 17:30'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName 				^ self			subclass: aSubclassName			parentClasses: Array new			instanceVariableNames: instVarNames			classVariableNames: classVarNames			poolDictionaries: poolDictionaries			category: aCategoryName.! !!OOPObject class methodsFor: 'subclass creation' stamp: 'yb 6/12/2018 17:21'!subclass: aSubclassName parentClasses: anArray instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName 	| res parentClassesOrderedCollection |		"create the normal squeak inheritance object - cannot call the method itself because it is overriden"	res := (ClassBuilder new)				superclass: OOPObject				subclass: aSubclassName				instanceVariableNames: instVarNames				classVariableNames: classVarNames				poolDictionaries: poolDictionaries				category: aCategoryName.				"if self isn't OOPObject we will insert it to the first index of the superclasses array"	parentClassesOrderedCollection := OrderedCollection new.	(self ~~ OOPObject) 		ifTrue: [parentClassesOrderedCollection addFirst: (OOPParent new parentClass: self ; inheritanceType: 'public')].	anArray do: [ :singleParentClass | parentClassesOrderedCollection addLast: singleParentClass].	"insert parentClassesArr to res.superclasses field"	res instVarNamed: 'superclasses' put: parentClassesOrderedCollection asArray.		"return the result"	^res.! !Object subclass: #OOPParent	instanceVariableNames: 'parentClass inheritanceType'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPParent methodsFor: 'getters' stamp: 'd 5/30/2018 17:46'!inheritanceType		^ inheritanceType.! !!OOPParent methodsFor: 'getters' stamp: 'd 5/30/2018 17:48'!parentClass		^ parentClass.! !!OOPParent methodsFor: 'setters' stamp: 'd 5/30/2018 17:53'!inheritanceType: aString		inheritanceType := aString.! !!OOPParent methodsFor: 'setters' stamp: 'sdf 5/30/2018 19:25'!parentClass: aClass		parentClass := aClass.! !!OOPParent methodsFor: 'initialize-release' stamp: 'd 5/30/2018 17:47'!initialize		parentClass := Object.		inheritanceType := 'public'.! !